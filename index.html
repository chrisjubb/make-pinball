<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - collada</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;

			}

			a { color: skyblue }
		</style>
	</head>
	<body>
		<div id="info">
			pinball
		</div>

		<script src="lib/three.min.js"></script>

		<script src="lib/ammo.js"></script>

		<script src="lib/underscore-min.js"></script>

		<script src="js/loaders/collada/Animation.js"></script>
		<script src="js/loaders/collada/AnimationHandler.js"></script>
		<script src="js/loaders/collada/KeyFrameAnimation.js"></script>

		<script src="js/loaders/ColladaLoader.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer, objects;
			var dae;
			var cameras = [];
			var leftButtonDown = false;
			var rightButtonDown = false;

			var leftButtonTimeDeactivate = 0.0;

			// physics
			var dynamicsWorld;
            var physicsMeshCallbacks = [];

            var planeBodies = [];
            var triangleMeshBodies = [];
            var ballBodies = [];
            var pointFlipperBodies = [];
            var flipperBodies = [];
            var ballStartingPositions = [];
            var flipperConstraints = [];
            var switchBodies = [];

            var groupPlane = 1;
            var groupTriangleMesh = 2;
            var groupBall = 4;
            var groupFlipper = 8;
            var groupFlipperPoint = 16;
            var groupSwitch = 32;

            // plane -> ball only
            var maskPlane = groupBall;
            // triangle mesh -> ball only
            var maskTriangleMesh = groupBall;
            // ball -> plane, triangle mesh, flipper, other balls
            var maskBall = groupPlane + groupTriangleMesh + groupFlipper + groupBall + groupSwitch;
            // flipper -> ball
            var maskFlipper = groupBall;
            // flipper point -> nothing
            var maskFlipperPoint = 0;
            // ghost -> ball
            var maskSwitch = groupBall;

            // BLENDER -> THREE
            // XYZ     -> +X +Z -Y

            function getNameIndex(child, stringIdent) {
            	if(child.name.indexOf(stringIdent) == 0) {
            		var idString = child.name.substring(stringIdent.length);
            		var id = parseInt(idString);
            		return {id: id, child: child};
            	}

            	return undefined;
            }

			function start() {
				var loader = new THREE.ColladaLoader();
				loader.options.convertUpAxis = true;

				var planes = [];
				var triangleMeshes = [];
				var balls = [];
				var pointFlippers = [];
				var flippers = [];
				var switches = [];

				loader.load( 'wire_forms.dae', function ( collada ) {

					initPhysics();

					dae = collada.scene;

					dae.traverse( function (child) {
						//console.log(child.name + " - " + dpos(child.position));

						if(child.name == "Plane") {
							planes.push(child);
						}

						if(child.name.indexOf("P_") == 0) {
							triangleMeshes.push(child);
						}

						if(child.name.indexOf("BALL") == 0) {
							balls.push(child);
						}

						var pointFlipper = getNameIndex(child, "POINT_FLIPPER_");
						if(pointFlipper) {
							pointFlippers[pointFlipper.id] = pointFlipper.child;
						}

						var flipper = getNameIndex(child, "FLIPPER_");
						if(flipper) {
							flippers[flipper.id] = flipper.child;
						}

						var switchObject = getNameIndex(child, "SWITCH_")
						if(switchObject) {
							switches[switchObject.id] = switchObject.child;
						}

						if(child.name == "Camera") {
							cameras.push(child);
						}

						if(child instanceof THREE.SkinnedMesh) {
							var animation = new THREE.Animation( child, child.geometry.animation );
							animation.play();
						}
					} );

					_.each(planes, function(child) {
						console.log("[!] Adding plane");
						planeBodies.push(addPlane(child));
					});

					_.each(triangleMeshes, function(child) {
						console.log("[!] Adding triangle mesh - " + child.name);
						child.visible = false;
						triangleMeshBodies.push(addTriangleMesh(child));
					});

					_.each(balls, function(child) {
						console.log("[!] Adding ball (" + child.name + ") - " + dpos(child.position));
						ballBodies.push(addBall(child));
						ballStartingPositions.push(child.position.clone());
					});

					_.each(pointFlippers, function(child) {
						console.log("[!] Adding point flipper");
						pointFlipperBodies.push(addFlipperPoint(child));
					});

					_.each(flippers, function(child, flipperIndex) {
						console.log("[!] Adding flipper");
						flipperBodies.push(addFlipper(child, flipperIndex));
					});

					_.each(switches, function(child) {
						console.log("[!] Adding switch");
						switchBodies.push(addSwitch(child));
					});

					dae.scale.x = dae.scale.y = dae.scale.z = 1.0;
					dae.updateMatrix();

					initScene();
					animate();

				} );
			}

			function dpos(pos) {
			if(pos) {
					return "[ " + pos.x + ", " + pos.y + ", " + pos.z + " ]";
				}
				else {
					return '[not valid]';
				}
			}

			function radians(degrees) {
			  return degrees * Math.PI / 180;
			}

			function degrees(radians) {
			  return radians * 180 / Math.PI;
			}

			function initPhysics() {
				var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                var overlappingPairCache = new Ammo.btDbvtBroadphase();
                var solver = new Ammo.btSequentialImpulseConstraintSolver();
                dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                dynamicsWorld.setGravity(new Ammo.btVector3(0, -2.6811, 21.8360));
			}

			function addTriangleMesh(original) {
				var physicsMesh = new Ammo.btTriangleMesh();

				original.updateMatrixWorld();

				var mesh = original.children[0];
				var geometry = mesh.geometry;
				_.each(geometry.faces, function(face) {

					var localV0 = geometry.vertices[face.a];
					var localV1 = geometry.vertices[face.b];
					var localV2 = geometry.vertices[face.c];

					var worldV0 = original.localToWorld(localV0.clone());
					var worldV1 = original.localToWorld(localV1.clone());
					var worldV2 = original.localToWorld(localV2.clone());

					physicsMesh.addTriangle(
									new Ammo.btVector3(worldV0.x, worldV0.y, worldV0.z),
									new Ammo.btVector3(worldV1.x, worldV1.y, worldV1.z),
									new Ammo.btVector3(worldV2.x, worldV2.y, worldV2.z)
									);
				});

				var shape = new Ammo.btBvhTriangleMeshShape(physicsMesh, true, true);

				var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(0, 0, 0));

                var mass = 0;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                body.setRestitution(0.0);
                dynamicsWorld.addRigidBody(body, groupTriangleMesh, maskTriangleMesh);
                body.activate();

                return body;
			}

			function addBall(original) {
				var pos = original.position.clone();
                var rot = new THREE.Quaternion();
                rot.setFromEuler(original.rotation);

                var shape = new Ammo.btSphereShape(0.135);
                shape.setMargin(0.04);
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 1;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                body.setRestitution(0.6);
                body.setDamping(0.04, 0.1);
               	body.setFriction(0.5);
                dynamicsWorld.addRigidBody(body, groupBall, maskBall);
                body.activate();

                addPhysicsCallback(original, body, transform);

                return body;
			}

			function addPlane(original) {
				var pos = original.position.clone();

				var shape = new Ammo.btStaticPlaneShape(new Ammo.btVector3(0, 1, 0), 0);

				var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 0;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                dynamicsWorld.addRigidBody(body, groupPlane, maskPlane);
                body.activate();

                return body;
			}

			function addToConvexHull(shape, threePosition) {
				shape.addPoint(new Ammo.btVector3(threePosition.x, threePosition.y, threePosition.z));
			}

			function addFlipperPoint(original) {
				var pos = original.position.clone();

				var shape = new Ammo.btSphereShape(0.00001);

				var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 0;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                dynamicsWorld.addRigidBody(body, groupFlipperPoint, maskFlipperPoint);
                body.activate();

                return body;
			}

			function addFlipper(original, flipperIndex) {
				var shape = new Ammo.btConvexHullShape();

				var child = original.children[0]; // should be the first one
				var mesh = child;
				var geometry = mesh.geometry;
				_.each(geometry.vertices, function(vertex) {
					addToConvexHull(shape, vertex);
				});

				// hide physics mesh
				original.children[0].visible = false;

				var pos = original.position.clone();
				var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 5;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                body.setRestitution(1.2);
                dynamicsWorld.addRigidBody(body, groupFlipper, maskFlipper);

				var hingeTransform = new Ammo.btTransform();
                hingeTransform.setIdentity();
                hingeTransform.setOrigin(new Ammo.btVector3(0,0.0,0));
                var hingeQuaternion = new Ammo.btQuaternion(0,0,0,1);
                hingeQuaternion.setEulerZYX(0.0, 0.0, 90.0);
                hingeQuaternion.normalize();
                hingeTransform.setRotation(hingeQuaternion);

                var hinge = new Ammo.btHingeConstraint(body, hingeTransform, true);

                var pointFlipperBody = pointFlipperBodies[flipperIndex];
                var tA = new Ammo.btTransform();
                tA.setIdentity();
                var tB = new Ammo.btTransform();
                tB.setIdentity();
                var dof = new Ammo.btGeneric6DofConstraint(body, pointFlipperBody,
                		tA, tB, true);
                dof.setLinearLowerLimit(new Ammo.btVector3(0,0,0));
                dof.setLinearUpperLimit(new Ammo.btVector3(0,0,0));
                dof.setAngularLowerLimit(new Ammo.btVector3(0,1,0));
                dof.setAngularUpperLimit(new Ammo.btVector3(0,0,0));

				var springyness = 0.9;
				hinge.setLimit(radians(-30.0), radians(40.0), 0.001, springyness, 1.0);

                dynamicsWorld.addConstraint(dof);
                dynamicsWorld.addConstraint(hinge);
                addPhysicsCallback(original, body, transform);

                flipperConstraints.push(hinge);

                body.activate();

                return body;
			}

			function addSwitch(original) {
				var pos = original.position.clone();
                var rot = new THREE.Quaternion();
                rot.setFromEuler(original.rotation);

                var shape = new Ammo.btBoxShape(new Ammo.btVector3(original.scale.x, original.scale.y, original.scale.y));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var body = new Ammo.btGhostObject();
                body.setCollisionShape(shape);
                body.setWorldTransform(transform);
                body.setCollisionFlags(4); // no collision response

                dynamicsWorld.addCollisionObject(body, groupSwitch, maskSwitch);
                body.activate();

                return body;
			}

			function addPhysicsCallback(object, body, transform) {
				physicsMeshCallbacks.push(function() {
                    body.getMotionState().getWorldTransform(transform);

                    var origin = transform.getOrigin();
                    object.position.set(origin.x(), origin.y(), origin.z());

                    var rotation = transform.getRotation();
                    object.quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w());
                });
			}

			function initScene() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000.0 );
				camera.position.x = 5.4;
				camera.position.y = 5.0;
				camera.position.z = 6.0;
				camera.lookAt( new THREE.Vector3(camera.position.x, 0, 1) );

				// Add the COLLADA

				scene.add( dae );

				// Lights

				scene.add( new THREE.AmbientLight( 0x050505 ) );

				var directionalLight = new THREE.DirectionalLight(0x050505 );
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

				window.addEventListener( 'keyup', function(evt) {
					if(evt.keyCode == 82) { // R
						_.each(ballBodies, function(body, i) {
							var transform = new Ammo.btTransform();
                			transform.setIdentity();
                			var pos = ballStartingPositions[i];
                			transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
							body.setWorldTransform(transform);
							body.setLinearVelocity(new Ammo.btVector3(0,0,0));
							body.setAngularVelocity(new Ammo.btVector3(0,0,0));
						});
					}
					else if(evt.keyCode == 65) { // 'A'
						leftButtonDown = false;
					}
					else if(evt.keyCode == 76) { // 'L'
						rightButtonDown = false;
					}
				}, false );

				window.addEventListener( 'keydown', function(evt) {
					//console.log(evt.keyCode);
					if(evt.keyCode == 65) { // 'A'
						if(leftButtonDown == false) {
							leftButtonTimeDeactivate = clock.elapsedTime + 0.25;
						}
						leftButtonDown = true;
					}
					else if(evt.keyCode == 76) { // 'L'
						rightButtonDown = true;
					}
				});


			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			var clock = new THREE.Clock();

			function render() {

				var delta = clock.getDelta();

				THREE.AnimationHandler.update( delta );

				_.each(flipperBodies, function(flipperBody) {
					flipperBody.forceActivationState(true);
				});
				_.each(flipperConstraints, function(flipperConstraint) {
					var upImpulse = 500.0;
					var downImpulse = -500.0;

					var targetVelocity = downImpulse;

					if(leftButtonDown || (clock.elapsedTime < leftButtonTimeDeactivate)) {
						targetVelocity = upImpulse;
					}

					var maxMotorImpulse = upImpulse * 5.0;
					flipperConstraint.enableAngularMotor(true, targetVelocity, maxMotorImpulse);
				});

				dynamicsWorld.stepSimulation(delta, 2);
				_.each(physicsMeshCallbacks, function(callback) {
					callback();
				});

				var dispatcher = dynamicsWorld.getDispatcher();
				for(var i = 0, n = dispatcher.getNumManifolds(); i < n; ++i) {
					var manifold = dispatcher.getManifoldByIndexInternal(i);

					// A ghost object
					if(manifold.getBody1().getCollisionFlags() == 4) {
						// todo - make a lookup, ghost.ptr -> switch id
						_.each(switchBodies, function(body) {
							if(manifold.getBody1().ptr == body.ptr) {
								console.log("switch body - " + body);
							}
						});
					}


				}

				renderer.render( scene, camera );

			}

			start();

		</script>
	</body>
</html>
