<!DOCTYPE html>
<html lang="en">
	<head>
		<title>makepinball.com</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;

			}

			a { color: skyblue }

			#configContainer {
				position: absolute;
				right: 0;
				top: 0;
				height: 100%;
				width: 20%;
				background-color: white;
			}

			#configButtons {
			}

			#configScrollContainer {
				height: 90%;
			}

			#config {
				overflow: scroll;
				width: 100%;
				height: 100%;
			}

			#canvasContainer {
				position: absolute;
				left: 0;
				top: 0;
				width: 80%;
				height: 100%;
				background-color: blue;
			}
		</style>
	</head>
	<body>
		<div id="info">
			pinball
		</div>
		<div id="canvasContainer"></div>
		<div id="configContainer">
			<div id="configButtons">
				<div><button onclick="configHide();">Hide</button></div>
				<div><button onclick="configOutputJson();">output json</button></div>
				<div><button onclick="configUpdate();">UPDATE</button></div>
			</div>
			<div id="configScrollContainer">
				<div id="config"></div>
			</div>
		</div>

		<script src="lib/three.min.js"></script>
		<script src="lib/ammo.js"></script>
		<script src="lib/underscore-min.js"></script>
		<script src="lib/jquery.js"></script>
		<script src="lib/backbone.js"></script>

		<script src="config/config.js"></script>

		<!-- three js -->
		<script src="js/loaders/collada/Animation.js"></script>
		<script src="js/loaders/collada/AnimationHandler.js"></script>
		<script src="js/loaders/collada/KeyFrameAnimation.js"></script>

		<script src="js/shaders/SSAOShader.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/EffectComposer.js"></script>

		<script src="js/loaders/ColladaLoader.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if(! Detector.webgl) Detector.addGetWebGLMessage();

			var stats;

			var camera, scene, renderer, objects;
			var dae;
			var cameras = [];
			var leftButtonDown = false;
			var rightButtonDown = false;

			// effects
			var depthMaterial, effectComposer, depthRenderTarget;
			var ssaoPass;
			var group;
			var depthScale = 1.0;
			var ssaoEnabled = false;

			// physics
			var physCfg = new Config().load("physics.config.json", "physics.settings.json");
            var physCfgView = new ConfigView({ model: physCfg });
            $("#config").html(physCfgView.render().el);

            // physics state - could turn into a class
			var dynamicsWorld;
            var physicsMeshCallbacks = [];
            var planeBodies = [];
            var triangleMeshBodies = [];
            var ballBodies = [];
            var pointFlipperBodies = [];
            var flipperBodies = [];
            var ballStartingPositions = [];
            var flipperConstraints = [];
            var switchBodies = [];

            var groupPlane = 1;
            var groupTriangleMesh = 2;
            var groupBall = 4;
            var groupFlipper = 8;
            var groupFlipperPoint = 16;
            var groupSwitch = 32;

            // plane -> ball only
            var maskPlane = groupBall;
            // triangle mesh -> ball only
            var maskTriangleMesh = groupBall;
            // ball -> plane, triangle mesh, flipper, other balls
            var maskBall = groupPlane + groupTriangleMesh + groupFlipper + groupBall + groupSwitch;
            // flipper -> ball
            var maskFlipper = groupBall;
            // flipper point -> nothing
            var maskFlipperPoint = 0;
            // ghost -> ball
            var maskSwitch = groupBall;

            // BLENDER -> THREE
            // XYZ     -> +X +Z -Y

            // config related
            function configHide() {
            	$("#configContainer").css("width", "0%");
            	$("#canvasContainer").css("width", "100%");
            	onWindowResize();
            }

            function configOutputJson() {
            	console.log(JSON.stringify(physCfg.getSettings()));
            }

            function configUpdate() {
            	physCfgView.updateValues();
            	initPhysics();
            }

            // blender export related
            function getNameIndex(child, stringIdent) {
            	if(child.name.indexOf(stringIdent) == 0) {
            		var idString = child.name.substring(stringIdent.length);
            		var id = parseInt(idString);
            		return {id: id, child: child};
            	}

            	return undefined;
            }

			function start() {
				physCfg.ready(function() {
					loadLevel();
				});
			}

			function loadLevel() {
				var loader = new THREE.ColladaLoader();
				loader.options.convertUpAxis = true;

				loader.load( 'wire_forms.dae', function ( collada ) {
					dae = collada.scene;

					dae.traverse(function (child) {
						var castShadow = true;
						if(child.name == "Plane") {
							castShadow = false; // no point
						}

						if(child.name == "Camera") {
							cameras.push(child);
						}

						if(child instanceof THREE.SkinnedMesh) {
							var animation = new THREE.Animation( child, child.geometry.animation );
							animation.play();
						}

						child.castShadow = castShadow;
					    child.receiveShadow = true;
					});

					dae.scale.x = dae.scale.y = dae.scale.z = 1.0;
					dae.updateMatrix();

					initPhysics();
					initScene();
					animate();
				});
			}

			function dpos(pos) {
				if(pos) {
					return "[ " + pos.x + ", " + pos.y + ", " + pos.z + " ]";
				}
				else {
					return '[not valid]';
				}
			}

			function radians(degrees) {
			  return degrees * Math.PI / 180;
			}

			function degrees(radians) {
			  return radians * 180 / Math.PI;
			}

			function initPhysics() {
				var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
                var overlappingPairCache = new Ammo.btDbvtBroadphase();
                var solver = new Ammo.btSequentialImpulseConstraintSolver();
                dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                dynamicsWorld.setGravity(new Ammo.btVector3(0, -2.6811, 21.8360));

	            physicsMeshCallbacks = [];
	            planeBodies = [];
	            triangleMeshBodies = [];
	            ballBodies = [];
	            pointFlipperBodies = [];
	            flipperBodies = [];
	            ballStartingPositions = [];
	            flipperConstraints = [];
	            switchBodies = [];

	            // collect into these first. this is so that we can init things that
	            // are dependant on other objects - eg the flippers are dependent on the
	            // flipper points existing.
                var planes = [];
				var triangleMeshes = [];
				var balls = [];
				var pointFlippers = [];
				var flippers = [];
				var switches = [];

				dae.traverse(function (child) {
					//console.log(child.name + " - " + dpos(child.position));

					if(child.name.indexOf("PLANE_") == 0) {
						planes.push(child);
					}

					if(child.name.indexOf("P_") == 0) {
						triangleMeshes.push(child);
					}

					if(child.name.indexOf("BALL") == 0) {
						balls.push(child);
					}

					var pointFlipper = getNameIndex(child, "POINT_FLIPPER_");
					if(pointFlipper) {
						pointFlippers[pointFlipper.id] = pointFlipper.child;
					}

					var flipper = getNameIndex(child, "FLIPPER_");
					if(flipper) {
						flippers[flipper.id] = flipper.child;
					}

					var switchObject = getNameIndex(child, "SWITCH_")
					if(switchObject) {
						switches[switchObject.id] = switchObject.child;
					}
				} );

				_.each(planes, function(child) {
					console.log("[!] Adding plane");
					planeBodies.push(addPlane(child));
				});

				_.each(triangleMeshes, function(child) {
					console.log("[!] Adding triangle mesh - " + child.name);
					child.visible = false;
					triangleMeshBodies.push(addTriangleMesh(child));
				});

				_.each(balls, function(child) {
					console.log("[!] Adding ball (" + child.name + ") - " + dpos(child.position));
					ballBodies.push(addBall(child));
					ballStartingPositions.push(child.position.clone());
				});

				_.each(pointFlippers, function(child) {
					console.log("[!] Adding point flipper");
					pointFlipperBodies.push(addFlipperPoint(child));
				});

				_.each(flippers, function(child, flipperIndex) {
					console.log("[!] Adding flipper");
					flipperBodies.push(addFlipper(child, flipperIndex));
				});

				_.each(switches, function(child) {
					console.log("[!] Adding switch");
					switchBodies.push(addSwitch(child));
				});
			}

			function addTriangleMesh(original) {
				var physicsMesh = new Ammo.btTriangleMesh();

				original.updateMatrixWorld();

				var mesh = original.children[0];
				var geometry = mesh.geometry;
				_.each(geometry.faces, function(face) {

					var localV0 = geometry.vertices[face.a];
					var localV1 = geometry.vertices[face.b];
					var localV2 = geometry.vertices[face.c];

					var worldV0 = original.localToWorld(localV0.clone());
					var worldV1 = original.localToWorld(localV1.clone());
					var worldV2 = original.localToWorld(localV2.clone());

					physicsMesh.addTriangle(
									new Ammo.btVector3(worldV0.x, worldV0.y, worldV0.z),
									new Ammo.btVector3(worldV1.x, worldV1.y, worldV1.z),
									new Ammo.btVector3(worldV2.x, worldV2.y, worldV2.z)
									);
				});

				var shape = new Ammo.btBvhTriangleMeshShape(physicsMesh, true, true);

				var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(0, 0, 0));

                var mass = 0;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                body.setRestitution(0.0);
                dynamicsWorld.addRigidBody(body, groupTriangleMesh, maskTriangleMesh);
                body.activate();

                return body;
			}

			function addBall(original) {
				var pos = original.position.clone();
                var rot = new THREE.Quaternion();
                rot.setFromEuler(original.rotation);

                var shape = new Ammo.btSphereShape(0.135);
                shape.setMargin(0.04);
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 1;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                body.setRestitution(0.6);
                body.setDamping(0.04, 0.1);
               	body.setFriction(0.5);
                dynamicsWorld.addRigidBody(body, groupBall, maskBall);
                body.activate();

                addPhysicsCallback(original, body, transform);

                return body;
			}

			function addPlane(original) {
				var pos = original.position.clone();

				var up = new THREE.Vector3(0, 1, 0);
				var output = up.applyQuaternion(original.quaternion);
				output.normalize();

				var shape = new Ammo.btStaticPlaneShape(new Ammo.btVector3(output.x, output.y, output.z), 0);

				var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 0;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                dynamicsWorld.addRigidBody(body, groupPlane, maskPlane);
                body.activate();

                return body;
			}

			function addToConvexHull(shape, threePosition) {
				shape.addPoint(new Ammo.btVector3(threePosition.x, threePosition.y, threePosition.z));
			}

			function addFlipperPoint(original) {
				var pos = original.position.clone();

				var shape = new Ammo.btSphereShape(0.00001);

				var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 0;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                dynamicsWorld.addRigidBody(body, groupFlipperPoint, maskFlipperPoint);
                body.activate();

                return body;
			}

			function addFlipper(original, flipperIndex) {
				var shape = new Ammo.btConvexHullShape();

				var child = original.children[0]; // should be the first one
				var mesh = child;
				var geometry = mesh.geometry;
				_.each(geometry.vertices, function(vertex) {
					addToConvexHull(shape, vertex);
				});

				// hide physics mesh
				original.children[0].visible = false;

				var pos = original.position.clone();
				var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var mass = 5;
                var localInertia = new Ammo.btVector3(0, 0, 0);
                shape.calculateLocalInertia(mass, localInertia);

                var motionState = new Ammo.btDefaultMotionState(transform);
                var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
                var body = new Ammo.btRigidBody(rigidBodyInfo);
                body.setRestitution(1.2);
                dynamicsWorld.addRigidBody(body, groupFlipper, maskFlipper);

				var hingeTransform = new Ammo.btTransform();
                hingeTransform.setIdentity();
                hingeTransform.setOrigin(new Ammo.btVector3(0,0.0,0));
                var hingeQuaternion = new Ammo.btQuaternion(0,0,0,1);
                hingeQuaternion.setEulerZYX(0.0, 180.0, 90.0);
                hingeQuaternion.normalize();
                hingeTransform.setRotation(hingeQuaternion);

                var hinge = new Ammo.btHingeConstraint(body, hingeTransform, true);

                var pointFlipperBody = pointFlipperBodies[flipperIndex];
                var tA = new Ammo.btTransform();
                tA.setIdentity();
                var tB = new Ammo.btTransform();
                tB.setIdentity();
                var dof = new Ammo.btGeneric6DofConstraint(body, pointFlipperBody,
                		tA, tB, true);
                dof.setLinearLowerLimit(new Ammo.btVector3(0,0,0));
                dof.setLinearUpperLimit(new Ammo.btVector3(0,0,0));
                dof.setAngularLowerLimit(new Ammo.btVector3(0,1,0));
                dof.setAngularUpperLimit(new Ammo.btVector3(0,0,0));

                var limitMin = physCfg.get("flipperLimitsMin" + flipperIndex);
                var limitMax = physCfg.get("flipperLimitsMax" + flipperIndex);

				var springyness = 0.9;
				hinge.setLimit(radians(limitMin), radians(limitMax), 0.001, springyness, 1.0);

                dynamicsWorld.addConstraint(dof);
                dynamicsWorld.addConstraint(hinge);
                addPhysicsCallback(original, body, transform, { rotation: [0, 1, 0], translation: [1,1,1] });

                flipperConstraints.push(hinge);

                body.activate();

                return body;
			}

			function addSwitch(original) {
				var pos = original.position.clone();
                var rot = new THREE.Quaternion();
                rot.setFromEuler(original.rotation);

                var shape = new Ammo.btBoxShape(new Ammo.btVector3(original.scale.x, original.scale.y, original.scale.y));
                var transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));

                var body = new Ammo.btGhostObject();
                body.setCollisionShape(shape);
                body.setWorldTransform(transform);
                body.setCollisionFlags(4); // no collision response

                dynamicsWorld.addCollisionObject(body, groupSwitch, maskSwitch);
                body.activate();

                return body;
			}

			function addPhysicsCallback(object, body, transform, limitsData) {

				var translationLimit = [1,1,1];
				if(limitsData && limitsData.translation) {
					translationLimit = limitsData.translation;
				}

				var rotationLimit = [1,1,1];
				if(limitsData && limitsData.rotation) {
					rotationLimit = limitsData.rotation;
				}

				physicsMeshCallbacks.push(function() {
                    body.getMotionState().getWorldTransform(transform);

                    var origin = transform.getOrigin();
                    object.position.set(origin.x() * translationLimit[0], origin.y() * translationLimit[1], origin.z() * translationLimit[2]);

                    var rotation = transform.getRotation();
                    object.quaternion.set(rotation.x() * rotationLimit[0], rotation.y() * rotationLimit[1], rotation.z() * rotationLimit[2], rotation.w());
                });
			}

			function initScene() {

				var container = getCanvasContainer();

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, container.width() / container.height(), 0.1, 1000.0 );
				camera.position.x = 5.4;
				camera.position.y = 5.5;
				camera.position.z = 6;
				camera.lookAt( new THREE.Vector3(camera.position.x, 0, 1.25) );

				// Add the COLLADA

				scene.add( dae );

				// Lights

				scene.add( new THREE.AmbientLight( 0x444444 ) );

				var directionalLight = new THREE.DirectionalLight(0x999999);
				directionalLight.position.x = 7.5;
				directionalLight.position.y = 5.9;
				directionalLight.position.z = 4.2;
				directionalLight.rotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), 0.0);
				directionalLight.castShadow = true;
				directionalLight.shadowDarkness = 0.6;
				directionalLight.shadowCameraNear = 0.5;
				directionalLight.shadowCameraFar = 15;
				directionalLight.shadowCameraLeft = -15;
				directionalLight.shadowCameraRight = 15;
				directionalLight.shadowCameraTop = 15;
				directionalLight.shadowCameraBottom = -15;
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( container.width(), container.height() );

				renderer.shadowMapBias = 0.0039;
				renderer.shadowMapWidth = 1024;
				renderer.shadowMapHeight = 1024;
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.cullFace = THREE.CullFaceBack;

				container.append( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.append( stats.domElement );

				initPostprocessing();

				//

				window.addEventListener( 'resize', onWindowResize, false );

				window.addEventListener( 'keyup', function(evt) {
					if(evt.keyCode == 82) { // R
						_.each(ballBodies, function(body, i) {
							var transform = new Ammo.btTransform();
                			transform.setIdentity();
                			var pos = ballStartingPositions[i];
                			transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
							body.setWorldTransform(transform);
							body.setLinearVelocity(new Ammo.btVector3(0,0,0));
							body.setAngularVelocity(new Ammo.btVector3(0,0,0));
						});
					}
					else if(evt.keyCode == 65) { // 'A'
						leftButtonDown = false;
					}
					else if(evt.keyCode == 76) { // 'L'
						rightButtonDown = false;
					}
				}, false );

				window.addEventListener( 'keydown', function(evt) {
					//console.log(evt.keyCode);
					if(evt.keyCode == 65) { // 'A'
						leftButtonDown = true;
					}
					else if(evt.keyCode == 76) { // 'L'
						rightButtonDown = true;
					}
				});
			}

			function initPostprocessing() {
				// Setup render pass
				var renderPass = new THREE.RenderPass( scene, camera );

				// Setup depth pass
				var depthShader = THREE.ShaderLib[ "depthRGBA" ];
				var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

				depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader,
					uniforms: depthUniforms, blending: THREE.NoBlending } );

				var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter };
				depthRenderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );

				// Setup SSAO pass
				ssaoPass = new THREE.ShaderPass( THREE.SSAOShader );
				ssaoPass.renderToScreen = true;
				//ssaoPass.uniforms[ "tDiffuse" ].value will be set by ShaderPass
				ssaoPass.uniforms[ "tDepth" ].value = depthRenderTarget;
				ssaoPass.uniforms[ 'size' ].value.set( window.innerWidth, window.innerHeight );
				ssaoPass.uniforms[ 'cameraNear' ].value = camera.near;
				ssaoPass.uniforms[ 'cameraFar' ].value = camera.far;
				ssaoPass.uniforms[ 'onlyAO' ].value = false;
				ssaoPass.uniforms[ 'aoClamp' ].value = 0.4;
				ssaoPass.uniforms[ 'lumInfluence' ].value = 0.5;

				// Add pass to effect composer
				effectComposer = new THREE.EffectComposer( renderer );
				effectComposer.addPass( renderPass );
				effectComposer.addPass( ssaoPass );
			}

			function getCanvasContainer() {
				return $("#canvasContainer");
			}

			function onWindowResize() {
				var container = getCanvasContainer();
				var width = container.width();
				var height = container.height();
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				renderer.setSize(width, height);

				// Resize renderTargets
				ssaoPass.uniforms[ 'size' ].value.set( width, height );

				var pixelRatio = renderer.getPixelRatio();
				var newWidth  = Math.floor( width / pixelRatio ) || 1;
				var newHeight = Math.floor( height / pixelRatio ) || 1;
				depthRenderTarget.setSize( newWidth, newHeight );
				effectComposer.setSize( newWidth, newHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
			}

			function processFlipper(flipperConstraint, buttonDown, multiplier) {
				var upImpulse = 500.0;
				var downImpulse = -500.0;

				var targetVelocity = downImpulse;

				if(buttonDown) {
					targetVelocity = upImpulse;
				}

				var maxMotorImpulse = upImpulse * 5.0;
				flipperConstraint.enableAngularMotor(true, targetVelocity * multiplier, maxMotorImpulse);
			}

			var clock = new THREE.Clock();

			function render() {

				var delta = clock.getDelta();

				THREE.AnimationHandler.update( delta );

				_.each(flipperBodies, function(flipperBody) {
					flipperBody.forceActivationState(true);
				});

				processFlipper(flipperConstraints[0], leftButtonDown, 1);
				processFlipper(flipperConstraints[1], rightButtonDown, -1);

				dynamicsWorld.stepSimulation(delta, 2);
				_.each(physicsMeshCallbacks, function(callback) {
					callback();
				});

				var dispatcher = dynamicsWorld.getDispatcher();
				for(var i = 0, n = dispatcher.getNumManifolds(); i < n; ++i) {
					var manifold = dispatcher.getManifoldByIndexInternal(i);

					// A ghost object
					if(manifold.getBody1().getCollisionFlags() == 4) {
						// todo - make a lookup, ghost.ptr -> switch id
						_.each(switchBodies, function(body) {
							if(manifold.getBody1().ptr == body.ptr) {
								console.log("switch body - " + body);
							}
						});
					}


				}

				if(ssaoEnabled) {
					// for post processing
					scene.overrideMaterial = depthMaterial;
					renderer.render(scene, camera, depthRenderTarget, true );
					// Render renderPass and SSAO shaderPass
					scene.overrideMaterial = null;
					effectComposer.render();
				}
				else {
					renderer.render(scene, camera);
				}
			}

			start();

		</script>
	</body>
</html>
